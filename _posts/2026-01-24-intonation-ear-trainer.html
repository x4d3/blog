---
emoji: üéß
layout: post
title: Intonation Ear Trainer
category: Music
description: A web app to practice musical intonation.
---
<style>
    body {
        font-family: sans-serif;
        text-align: center;
        margin-top: 40px;
    }

    button {
        font-size: 18px;
        padding: 10px 20px;
        margin: 8px;
    }

    #note {
        font-size: 36px;
        margin: 20px;
    }

    #feedback {
        font-size: 28px;
        margin: 20px;
        height: 40px;
    }

    #summary {
        font-size: 22px;
        margin-top: 30px;
    }

    #volumeControl {
        margin: 12px;
    }

    #volumeLabel {
        font-weight: bold;
        margin-left: 8px;
    }
</style>

<button id="startBtn">Start Game</button>
<div id="note"></div>

<div id="controls" style="display:none;">
    <button id="replayBtn">üîÅ Replay</button>
    <br>
    <button id="flatBtn">‚¨á Flat</button>
    <button id="sharpBtn">‚¨Ü Sharp</button>
</div>

<div id="feedback"></div>
<div id="summary"></div>

<div id="volumeControl">
    <label for="volumeSlider">Volume</label>
    <input type="range" id="volumeSlider" min="0" max="100" value="80"/>
    <span id="volumeLabel">80 %</span>
</div>

<script type="module">

    /* AudioController: manages AudioContext, master gain, smooth volume and per-note play/stop */
    class AudioController {
        constructor() {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.audioCtx.createGain();
            this.masterGain.gain.value = 0.8;
            this.masterGain.connect(this.audioCtx.destination);

            this.active = {}; // holds oscillator, gain, stopTimer when a note is playing
            this.EPSILON = 0.0001;
            this.VOLUME_SMOOTH_TC = 0.03;
        }

        async resumeIfSuspended() {
            if (this.audioCtx.state === 'suspended') {
                await this.audioCtx.resume();
            }
        }

        setVolumePercent(percent) {
            const target = Math.max(percent / 100, this.EPSILON);
            const now = this.audioCtx.currentTime;
            this.masterGain.gain.cancelScheduledValues(now);
            this.masterGain.gain.setTargetAtTime(target, now, this.VOLUME_SMOOTH_TC);
        }

        stopActiveNote() {
            if ('stopTimer' in this.active) {
                clearTimeout(this.active.stopTimer);
                delete this.active.stopTimer;
            }

            if (this.active.oscillator && this.active.gain) {
                const now = this.audioCtx.currentTime;
                try {
                    const g = this.active.gain.gain;
                    g.cancelScheduledValues(now);
                    g.setValueAtTime(g.value || this.EPSILON, now);
                    g.linearRampToValueAtTime(this.EPSILON, now + 0.05);
                    this.active.oscillator.stop(now + 0.05);
                } catch (e) {
                    // ignore if already stopped
                }

                setTimeout(() => {
                    try {
                        this.active.oscillator.disconnect();
                    } catch (e) {
                    }
                    try {
                        this.active.gain.disconnect();
                    } catch (e) {
                    }
                }, 120);

                delete this.active.oscillator;
                delete this.active.gain;
            }
        }

        playFrequency(freq, durationSeconds) {
            this.stopActiveNote();

            const osc = this.audioCtx.createOscillator();
            const gainNode = this.audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;

            const now = this.audioCtx.currentTime;
            gainNode.gain.setValueAtTime(0.0, now);
            gainNode.gain.linearRampToValueAtTime(0.2, now + 0.01);

            osc.connect(gainNode);
            gainNode.connect(this.masterGain);
            osc.start();

            this.active.oscillator = osc;
            this.active.gain = gainNode;

            this.active.stopTimer = setTimeout(() => {
                const t = this.audioCtx.currentTime;
                try {
                    const g = gainNode.gain;
                    g.cancelScheduledValues(t);
                    g.setValueAtTime(g.value || this.EPSILON, t);
                    g.linearRampToValueAtTime(this.EPSILON, t + 0.05);
                    osc.stop(t + 0.05);
                } catch (e) {
                }
                setTimeout(() => {
                    try {
                        osc.disconnect();
                    } catch (e) {
                    }
                    try {
                        gainNode.disconnect();
                    } catch (e) {
                    }
                    delete this.active.oscillator;
                    delete this.active.gain;
                }, 120);
                delete this.active.stopTimer;
            }, durationSeconds * 1000);
        }

        noteToFrequency(note) {
            const map = {C: -9, D: -7, E: -5, F: -4, G: -2, A: 0, B: 2};
            const m = note.match(/^([A-G])(‚ôØ|#?)(\d)$/);
            if (!m) return 440;
            const [, letter, sharp, octave] = m;
            const semitones = map[letter] + (sharp ? 1 : 0) + (octave - 4) * 12;
            return 440 * Math.pow(2, semitones / 12);
        }
    }

    /* IntonationTrainer: UI wiring and game logic; provides a start() method */
    class IntonationTrainer {
        constructor(audioController) {
            this.audio = audioController;

            // UI
            this.startBtn = document.getElementById('startBtn');
            this.noteDiv = document.getElementById('note');
            this.controls = document.getElementById('controls');
            this.feedbackDiv = document.getElementById('feedback');
            this.summaryDiv = document.getElementById('summary');
            this.replayBtn = document.getElementById('replayBtn');
            this.flatBtn = document.getElementById('flatBtn');
            this.sharpBtn = document.getElementById('sharpBtn');

            this.volumeSlider = document.getElementById('volumeSlider');
            this.volumeLabel = document.getElementById('volumeLabel');

            // game state
            this.notes = ['C3', 'C‚ôØ3', 'D3', 'D‚ôØ3', 'E3', 'F3', 'F‚ôØ3', 'G3', 'G‚ôØ3', 'A3', 'A‚ôØ3', 'B3', 'C4'];
            this.roundIndex = 0;
            this.score = 0;
            this.history = [];
            this.correctAnswer = '';
            this.detunedFrequency = 0;
            this.currentNoteName = '';
            this.playSequenceFn = null;

            this._bindEvents();
            this._initVolumeUI();
        }

        _bindEvents() {
            this.startBtn.addEventListener('click', () => this.start());

            this.volumeSlider.addEventListener('input', (e) => {
                const v = Number(e.target.value);
                this.audio.setVolumePercent(v);
                this.volumeLabel.textContent = `${v} %`;
            });

            this.replayBtn.addEventListener('click', () => {
                this.audio.stopActiveNote();
                if (this.playSequenceFn) this.playSequenceFn();
            });

            this.flatBtn.addEventListener('click', () => this._answer('flat'));
            this.sharpBtn.addEventListener('click', () => this._answer('sharp'));
        }

        _initVolumeUI() {
            const value = Math.round(this.audio.masterGain.gain.value * 100);
            this.volumeSlider.value = value;
            this.volumeLabel.textContent = `${value} %`;
        }

        /* start: publicly callable method to start the trainer programmatically */
        async start() {
            await this.audio.resumeIfSuspended();
            this.audio.setVolumePercent(Number(this.volumeSlider.value));
            this.startBtn.style.display = 'none';
            this.roundIndex = 0;
            this.score = 0;
            this.history = [];
            this.summaryDiv.textContent = '';
            this.nextRound();
        }

        nextRound() {
            if (this.roundIndex >= 10) {
                this._endGame();
                return;
            }
            this.feedbackDiv.textContent = '';
            this.controls.style.display = 'none';
            this.roundIndex++;

            this.currentNoteName = this.notes[Math.floor(Math.random() * this.notes.length)];
            const baseFreq = this.audio.noteToFrequency(this.currentNoteName);
            this.correctAnswer = Math.random() < 0.5 ? 'flat' : 'sharp';
            const cents = 20;
            const factor = Math.pow(2, cents / 1200);
            this.detunedFrequency = this.correctAnswer === 'sharp' ? baseFreq * factor : baseFreq / factor;

            this.noteDiv.textContent = `Question ${this.roundIndex}: ${this.currentNoteName}`;

            this.playSequenceFn = () => {
                this.audio.stopActiveNote();
                this.audio.playFrequency(baseFreq, 2);
                setTimeout(() => {
                    this.audio.playFrequency(this.detunedFrequency, 2);
                    this.controls.style.display = 'block';
                }, 2200);
            };

            this.playSequenceFn();
        }

        _answer(choice) {
            const correct = choice === this.correctAnswer;
            if (correct) this.score++;
            this.history.push({note: this.currentNoteName, question: this.roundIndex, result: correct});
            this.feedbackDiv.textContent = correct ? '‚úÖ Correct!' : '‚ùå Wrong';
            this.controls.style.display = 'none';
            setTimeout(() => this.nextRound(), 1200);
        }

        _endGame() {
            this.audio.stopActiveNote();
            this.noteDiv.textContent = 'üéâ Game Over';
            this.feedbackDiv.textContent = '';
            this.controls.style.display = 'none';
            this.summaryDiv.innerHTML = `
      <strong>Final Score:</strong> ${this.score} / 10<br><br>
      ${this.history.map(h => `Q${h.question}:${h.note} ${h.result ? '‚úÖ' : '‚ùå'}`).join(' ')}
    `;
        }
    }

    /* Instantiate controller and trainer */
    const audioController = new AudioController();
    const trainer = new IntonationTrainer(audioController);

    /* Expose trainer.start() to the global scope so it can be called programmatically if desired */
    window.IntonationTrainerInstance = trainer;
</script>
