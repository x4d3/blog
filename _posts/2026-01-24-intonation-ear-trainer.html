---
emoji: üéß
layout: post
title: Intonation Ear Trainer
category: Music
description: A web app to practice musical intonation.
---
<!-- Ensure VexFlow is available; adjust path as needed for your site -->
<script src="{{"/assets/js/vexflow.js" | relative_url }}"></script>
<style>
    :root {
        --control-size: 20px;
    }

    body {
        font-family: sans-serif;
        text-align: center;
        margin-top: 24px;
        padding: 8px;
    }

    button {
        font-size: 18px;
        padding: 14px 22px;
        margin: 10px;
        border-radius: 8px;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
    }

    #note {
        font-size: 26px;
        margin: 8px;
    }

    #vex {
        margin: 0 auto 12px;
        width: 100%;
        max-width: 320px;
        height: 120px;
        background-color: #f9f9f9;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #controls {
        margin-top: 12px;
    }

    #feedback {
        font-size: 20px;
        margin: 12px;
        min-height: 28px;
    }

    #summary {
        font-size: 18px;
        margin-top: 18px;
        word-break: break-word;
    }

    #volumeControl {
        margin: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        flex-wrap: wrap;
    }

    #volumeSlider {
        width: 70%;
        max-width: 240px;
        touch-action: pan-y;
    }

    #volumeLabel {
        font-weight: bold;
        margin-left: 8px;
        min-width: 48px;
        text-align: left;
    }

    /* Make inputs and buttons larger on small screens */
    @media (max-width: 420px) {
        button {
            font-size: 20px;
            padding: 16px 24px;
        }

        #vex {
            height: 120px;
        }
    }
</style>
<div id="volumeControl">
    <label for="volumeSlider">Volume</label>
    <input type="range" id="volumeSlider" min="0" max="100" value="80"/>
    <span id="volumeLabel">80 %</span>
</div>

<button id="startBtn" aria-label="Start game">Start Game</button>
<div id="note" aria-live="polite"></div>
<div id="vex" role="img" aria-label="musical note"></div>

<div id="controls" style="display:none;">
    <button id="replayBtn">üîÅ Replay</button>
    <br>
    <button id="flatBtn">‚¨á Flat</button>
    <button id="sharpBtn">‚¨Ü Sharp</button>
</div>

<div id="feedback" aria-live="polite"></div>
<div id="summary"></div>

<script type="module">
    /* AudioController class */
    class AudioController {
        constructor() {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.audioCtx.createGain();
            this.masterGain.gain.value = 0.8;
            this.masterGain.connect(this.audioCtx.destination);

            this.active = {}; // holds oscillator, gain, stopTimer when a note is playing
            this.EPSILON = 0.0001;
            this.VOLUME_SMOOTH_TC = 0.03;
        }

        async resumeIfSuspended() {
            if (this.audioCtx.state === 'suspended') {
                await this.audioCtx.resume();
            }
        }

        setVolumePercent(percent) {
            const target = Math.max(percent / 100, this.EPSILON);
            const now = this.audioCtx.currentTime;
            this.masterGain.gain.cancelScheduledValues(now);
            this.masterGain.gain.setTargetAtTime(target, now, this.VOLUME_SMOOTH_TC);
        }

        stopActiveNote() {
            if ('stopTimer' in this.active) {
                clearTimeout(this.active.stopTimer);
                delete this.active.stopTimer;
            }

            if (this.active.oscillator && this.active.gain) {
                const now = this.audioCtx.currentTime;
                try {
                    const g = this.active.gain.gain;
                    g.cancelScheduledValues(now);
                    g.setValueAtTime(g.value || this.EPSILON, now);
                    g.linearRampToValueAtTime(this.EPSILON, now + 0.05);
                    this.active.oscillator.stop(now + 0.05);
                } catch (e) {
                    // ignore
                }

                setTimeout(() => {
                    try {
                        this.active.oscillator.disconnect();
                    } catch (e) {
                    }
                    try {
                        this.active.gain.disconnect();
                    } catch (e) {
                    }
                }, 120);

                delete this.active.oscillator;
                delete this.active.gain;
            }
        }

        playFrequency(freq, durationSeconds) {
            this.stopActiveNote();

            const osc = this.audioCtx.createOscillator();
            const gainNode = this.audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;

            const now = this.audioCtx.currentTime;
            gainNode.gain.setValueAtTime(0.0, now);
            gainNode.gain.linearRampToValueAtTime(0.2, now + 0.01);

            osc.connect(gainNode);
            gainNode.connect(this.masterGain);
            osc.start();

            this.active.oscillator = osc;
            this.active.gain = gainNode;

            this.active.stopTimer = setTimeout(() => {
                const t = this.audioCtx.currentTime;
                try {
                    const g = gainNode.gain;
                    g.cancelScheduledValues(t);
                    g.setValueAtTime(g.value || this.EPSILON, t);
                    g.linearRampToValueAtTime(this.EPSILON, t + 0.05);
                    osc.stop(t + 0.05);
                } catch (e) {
                }
                setTimeout(() => {
                    try {
                        osc.disconnect();
                    } catch (e) {
                    }
                    try {
                        gainNode.disconnect();
                    } catch (e) {
                    }
                    delete this.active.oscillator;
                    delete this.active.gain;
                }, 120);
                delete this.active.stopTimer;
            }, durationSeconds * 1000);
        }

        noteToFrequency(note) {
            const map = {C: -9, D: -7, E: -5, F: -4, G: -2, A: 0, B: 2};
            const m = note.match(/^([A-G])(‚ôØ|#?)(\d)$/);
            if (!m) return 440;
            const [, letter, sharp, octave] = m;
            const semitones = map[letter] + (sharp ? 1 : 0) + (octave - 4) * 12;
            return 440 * Math.pow(2, semitones / 12);
        }
    }

    /* IntonationTrainer class (lazy AudioController) */
    class IntonationTrainer {
        constructor(existingAudioController = null) {
            this.audio = existingAudioController; // may be null; created on first gesture or start()
            this.startBtn = document.getElementById('startBtn');
            this.noteDiv = document.getElementById('note');
            this.vexContainer = document.getElementById('vex');
            this.controls = document.getElementById('controls');
            this.feedbackDiv = document.getElementById('feedback');
            this.summaryDiv = document.getElementById('summary');
            this.replayBtn = document.getElementById('replayBtn');
            this.flatBtn = document.getElementById('flatBtn');
            this.sharpBtn = document.getElementById('sharpBtn');

            this.volumeSlider = document.getElementById('volumeSlider');
            this.volumeLabel = document.getElementById('volumeLabel');

            this.notes = ['C4', 'C‚ôØ4', 'D4', 'D‚ôØ4', 'E4', 'F4', 'F‚ôØ4', 'G4', 'G‚ôØ4', 'A4', 'A‚ôØ4', 'B4', 'C5'];
            this.roundIndex = 0;
            this.score = 0;
            this.history = [];
            this.correctAnswer = '';
            this.detunedFrequency = 0;
            this.currentNoteName = '';
            this.playSequenceFn = null;
            this.vfRenderer = null;

            this._bindEvents();
            this._initVolumeUI();

            // Ensure audio can be resumed on first gesture without forcing game start
            this._attachFirstGestureResume();
            window.addEventListener('resize', () => this._redrawVexIfNeeded());
        }

        _bindEvents() {
            this.startBtn.addEventListener('click', () => this.start());

            this.volumeSlider.addEventListener('input', (e) => {
                const v = Number(e.target.value);
                if (this.audio) this.audio.setVolumePercent(v);
                this.volumeLabel.textContent = `${v} %`;
            });

            this.replayBtn.addEventListener('click', () => {
                if (this.audio) this.audio.stopActiveNote();
                if (this.playSequenceFn) this.playSequenceFn();
            });

            this.flatBtn.addEventListener('click', () => this._answer('flat'));
            this.sharpBtn.addEventListener('click', () => this._answer('sharp'));
        }

        _initVolumeUI() {
            const value = this.audio ? Math.round(this.audio.masterGain.gain.value * 100) : Number(this.volumeSlider.value || 80);
            this.volumeSlider.value = value;
            this.volumeLabel.textContent = `${value} %`;
        }

        async _ensureAudio() {
            if (!this.audio) {
                this.audio = new AudioController();
                // set slider volume smoothly on creation
                this.audio.setVolumePercent(Number(this.volumeSlider.value));
                this._initVolumeUI();
            }
            await this.audio.resumeIfSuspended();
        }

        _attachFirstGestureResume() {
            const handler = async () => {
                try {
                    await this._ensureAudio();
                } catch (e) {
                }
                removeListeners();
            };
            const removeListeners = () => {
                document.removeEventListener('pointerdown', handler);
                document.removeEventListener('touchstart', handler);
                document.removeEventListener('click', handler);
            };
            document.addEventListener('pointerdown', handler, {once: true});
            document.addEventListener('touchstart', handler, {once: true, passive: true});
            document.addEventListener('click', handler, {once: true});
        }

        async start() {
            await this._ensureAudio();
            this.startBtn.style.display = 'none';
            this.roundIndex = 0;
            this.score = 0;
            this.history = [];
            this.summaryDiv.textContent = '';
            this.nextRound();
        }

        nextRound() {
            if (this.roundIndex >= 10) {
                this._endGame();
                return;
            }
            this.feedbackDiv.textContent = '';
            this.controls.style.display = 'none';
            this.roundIndex++;

            this.currentNoteName = this.notes[Math.floor(Math.random() * this.notes.length)];
            const baseFreq = this.audio.noteToFrequency(this.currentNoteName);
            this.correctAnswer = Math.random() < 0.5 ? 'flat' : 'sharp';
            const cents = 20;
            const factor = Math.pow(2, cents / 1200);
            this.detunedFrequency = this.correctAnswer === 'sharp' ? baseFreq * factor : baseFreq / factor;

            this.noteDiv.textContent = `Question ${this.roundIndex}: ${this.currentNoteName}`;

            this._drawVexNote(this.currentNoteName);

            this.playSequenceFn = () => {
                this.audio.stopActiveNote();
                this.audio.playFrequency(baseFreq, 2);
                setTimeout(() => {
                    this.audio.playFrequency(this.detunedFrequency, 2);
                    this.controls.style.display = 'block';
                }, 2200);
            };

            this.playSequenceFn();
        }

        _answer(choice) {
            const correct = choice === this.correctAnswer;
            if (correct) this.score++;
            this.history.push({note: this.currentNoteName, question: this.roundIndex, result: correct});
            this.feedbackDiv.textContent = correct ? '‚úÖ Correct!' : '‚ùå Wrong';
            this.controls.style.display = 'none';
            setTimeout(() => this.nextRound(), 1200);
        }

        _endGame() {
            if (this.audio) this.audio.stopActiveNote();
            this.noteDiv.textContent = 'üéâ Game Over';
            this.feedbackDiv.textContent = '';
            this.controls.style.display = 'none';
            this.summaryDiv.innerHTML = `
      <strong>Final Score:</strong> ${this.score} / 10<br><br>
      ${this.history.map(h => `Q${h.question}:${h.note} ${h.result ? '‚úÖ' : '‚ùå'}`).join(' ')}
    `;
        }

        /* VexFlow helpers - responsive rendering */
        _mapToVexKey(noteName) {
            const m = noteName.match(/^([A-G])(‚ôØ|#?)(\d)$/);
            if (!m) return {key: 'c/4', accidental: null};
            const [, letter, sharp, octave] = m;
            const key = `${letter.toLowerCase()}/${octave}`;
            const accidental = sharp ? '#' : null;
            return {key, accidental};
        }

        _clearVex() {
            if (this.vfRenderer) {
                this.vexContainer.innerHTML = '';
                this.vfRenderer = null;
            } else {
                this.vexContainer.innerHTML = '';
            }
        }

        _redrawVexIfNeeded() {
            if (this.currentNoteName) this._drawVexNote(this.currentNoteName);
        }

        _drawVexNote(noteName) {
            // support multiple VexFlow globals (VexFlow, Vex)
            const VF = window.VexFlow || (window.Vex && window.Vex.Flow) || window.Vex;
            if (!VF) {
                // library not loaded ‚Äî skip silently
                return;
            }

            this._clearVex();

            const containerWidth = Math.max(120, Math.min(this.vexContainer.clientWidth || 200, 480));
            const width = containerWidth;
            const height = Math.round(Math.max(80, Math.min(160, this.vexContainer.clientHeight || 100)));

            this.vfRenderer = new VF.Renderer(this.vexContainer, VF.Renderer.Backends.SVG);
            this.vfRenderer.resize(width, height);
            const context = this.vfRenderer.getContext();

            const stave = new VF.Stave(4, 8, width - 12);
            stave.addClef('treble');
            stave.setContext(context).draw();

            const {key, accidental} = this._mapToVexKey(noteName);
            const staveNote = new VF.StaveNote({clef: 'treble', keys: [key], duration: 'q'});
            if (accidental) {
                staveNote.addModifier(new VF.Accidental(accidental), 0);
            }

            VF.Formatter.FormatAndDraw(context, stave, [staveNote]);
        }
    }

    /* Instantiate trainer (audio is created lazily on gesture/start) */
    const trainer = new IntonationTrainer();
    window.IntonationTrainerInstance = trainer;
</script>
