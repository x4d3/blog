---
emoji: üéß
layout: post
title: Intonation Ear Trainer
category: Music
description: A web app to practice musical intonation.
---

<style>
    body {
        font-family: sans-serif;
        text-align: center;
        margin-top: 40px;
    }

    button {
        font-size: 18px;
        padding: 10px 20px;
        margin: 8px;
    }

    #note {
        font-size: 36px;
        margin: 20px;
    }

    #feedback {
        font-size: 28px;
        margin: 20px;
        height: 40px;
    }

    #summary {
        font-size: 22px;
        margin-top: 30px;
    }

    #volumeControl {
        margin: 12px;
    }

    #volumeLabel {
        font-weight: bold;
        margin-left: 8px;
    }
</style>


<button id="startBtn">Start Game</button>

<div id="note"></div>



<div id="controls" style="display:none;">
    <button id="replayBtn">üîÅ Replay</button>
    <br>
    <button id="flatBtn">‚¨á Flat</button>
    <button id="sharpBtn">‚¨Ü Sharp</button>
</div>

<div id="feedback"></div>
<div id="summary"></div>
<div id="volumeControl">
    <label for="volumeSlider">Volume</label>
    <input type="range" id="volumeSlider" min="0" max="100" value="80" />
    <span id="volumeLabel">80 %</span>
</div>
<script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // master gain for overall volume control
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.8; // default 80%
    masterGain.connect(audioCtx.destination);

    // Track the currently playing nodes and timers
    let currentOsc = null;
    let currentGain = null;
    let currentStopTimer = null;

    function stopCurrentNote() {
        // clear any JS timers that would stop the oscillator later
        if (currentStopTimer) {
            clearTimeout(currentStopTimer);
            currentStopTimer = null;
        }

        if (currentOsc && currentGain) {
            const now = audioCtx.currentTime;
            // smooth fade-out to avoid clicks
            try {
                currentGain.gain.cancelScheduledValues(now);
                // read current value via setValueAtTime to capture it
                currentGain.gain.setValueAtTime(currentGain.gain.value || 0.0001, now);
                currentGain.gain.linearRampToValueAtTime(0.0001, now + 0.05);
                currentOsc.stop(now + 0.05);
            } catch (e) {
                // ignore if stop was already scheduled or node already stopped
            }

            // disconnect after a short delay to allow stop to take effect
            setTimeout(() => {
                try { currentOsc.disconnect(); } catch (e) {}
                try { currentGain.disconnect(); } catch (e) {}
            }, 120);

            currentOsc = null;
            currentGain = null;
        }
    }

    function playFrequency(freq, duration) {
        // ensure any previous note is stopped
        stopCurrentNote();

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = "sine";
        osc.frequency.value = freq;

        const now = audioCtx.currentTime;
        // quick attack
        gain.gain.setValueAtTime(0.0, now);
        gain.gain.linearRampToValueAtTime(0.2, now + 0.01);

        // connect per-note gain into the master gain
        osc.connect(gain);
        gain.connect(masterGain);

        osc.start();

        currentOsc = osc;
        currentGain = gain;

        // schedule stop using a JS timer so we can clear it if needed
        currentStopTimer = setTimeout(() => {
            const t = audioCtx.currentTime;
            try {
                currentGain.gain.cancelScheduledValues(t);
                currentGain.gain.setValueAtTime(currentGain.gain.value || 0.0001, t);
                currentGain.gain.linearRampToValueAtTime(0.0001, t + 0.05);
                currentOsc.stop(t + 0.05);
            } catch (e) {}
            // cleanup after stop
            setTimeout(() => {
                try { currentOsc.disconnect(); } catch (e) {}
                try { currentGain.disconnect(); } catch (e) {}
                currentOsc = null;
                currentGain = null;
            }, 120);
            currentStopTimer = null;
        }, duration * 1000);
    }

    function noteToFrequency(note) {
        const map = {C: -9, D: -7, E: -5, F: -4, G: -2, A: 0, B: 2};
        const m = note.match(/^([A-G])(‚ôØ?)(\d)$/);
        if (!m) return 440;
        const [, letter, sharp, octave] = m;
        const semitones =
            map[letter] + (sharp ? 1 : 0) + (octave - 4) * 12;
        return 440 * Math.pow(2, semitones / 12);
    }

    const notes = [
        "C3", "C‚ôØ3", "D3", "D‚ôØ3", "E3", "F3",
        "F‚ôØ3", "G3", "G‚ôØ3", "A3", "A‚ôØ3", "B3", "C4"
    ];

    let round = 0;
    let score = 0;
    let history = [];
    let correctAnswer = "";
    let detunedFreq = 0;
    let playNotes = null;
    let note = null;
    const startBtn = document.getElementById("startBtn");
    const noteDiv = document.getElementById("note");
    const controls = document.getElementById("controls");
    const feedbackDiv = document.getElementById("feedback");
    const summaryDiv = document.getElementById("summary");

    // volume UI
    const volumeSlider = document.getElementById("volumeSlider");
    const volumeLabel = document.getElementById("volumeLabel");

    // initialize slider to masterGain value
    volumeSlider.value = Math.round(masterGain.gain.value * 100);
    volumeLabel.textContent = `${volumeSlider.value} %`;

    volumeSlider.oninput = (e) => {
        const raw = Number(e.target.value);
        // avoid exact 0 (exponential ramps can't hit 0 and tiny values prevent clicks)
        const target = Math.max(raw / 100, 0.0001);
        const now = audioCtx.currentTime;
        masterGain.gain.cancelScheduledValues(now);
        // smooth toward target with a short time constant (0.03s)
        masterGain.gain.setTargetAtTime(target, now, 0.03);
        volumeLabel.textContent = `${raw} %`;
    };

    startBtn.onclick = () => {
        // resume audio context on user gesture to satisfy browser autoplay policy
        if (audioCtx.state === "suspended") {
            audioCtx.resume();
        }

        // ensure master gain reflects slider after resume
        const sliderTarget = Math.max(Number(volumeSlider.value) / 100, 0.0001);
        masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
        masterGain.gain.setTargetAtTime(sliderTarget, audioCtx.currentTime, 0.03);

        startBtn.style.display = "none";
        round = 0;
        score = 0;
        history = [];
        summaryDiv.textContent = "";
        nextRound();
    };

    function nextRound() {
        if (round >= 10) {
            endGame();
            return;
        }

        feedbackDiv.textContent = "";
        controls.style.display = "none";
        round++;

        note = notes[Math.floor(Math.random() * notes.length)];
        const baseFreq = noteToFrequency(note);
        correctAnswer = Math.random() < 0.5 ? "flat" : "sharp";
        const cents = 20;
        const factor = Math.pow(2, cents / 1200);

        detunedFreq =
            correctAnswer === "sharp"
                ? baseFreq * factor
                : baseFreq / factor;

        noteDiv.textContent = `Question ${round}: ${note}`;

        playNotes = () => {
            // stop any current note before starting sequence
            stopCurrentNote();
            playFrequency(baseFreq, 2);
            setTimeout(() => {
                // when second note starts, playFrequency will stop the first note
                playFrequency(detunedFreq, 2);
                controls.style.display = "block";
            }, 2200);
        };

        playNotes();
    }

    function answer(choice) {
        const correct = choice === correctAnswer;
        if (correct) score++;

        history.push({
            note,
            question: round,
            result: correct
        });

        feedbackDiv.textContent = correct ? "‚úÖ Correct!" : "‚ùå Wrong";
        controls.style.display = "none";

        setTimeout(nextRound, 1200);
    }

    document.getElementById("flatBtn").onclick = () => answer("flat");
    document.getElementById("sharpBtn").onclick = () => answer("sharp");

    document.getElementById("replayBtn").onclick = () => {
        // stop any current note before replaying
        stopCurrentNote();
        playNotes();
    };

    function endGame() {
        // stop any remaining sound
        stopCurrentNote();

        noteDiv.textContent = "üéâ Game Over";
        feedbackDiv.textContent = "";
        controls.style.display = "none";

        summaryDiv.innerHTML = `
        <strong>Final Score:</strong> ${score} / 10<br><br>
        ${history.map(({question, note, result}) =>
            `Q${question}:${note}  ${result ? "‚úÖ" : "‚ùå"}`
        ).join(" ")}
      `;
    }
</script>
